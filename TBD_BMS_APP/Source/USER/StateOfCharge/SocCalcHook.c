//=======================================Copyright(c)===========================================
// 								  深圳易马达科技有限公司
//---------------------------------------文件信息----------------------------------------------
//文件名   	: SocCalcHook.c
//创建人  	: Handry
//创建日期	:
//描述	    : SOC 辅助计算模块
//-----------------------------------------------当前版本修订----------------------------------
//修改人   	:
//版本	    :
//修改日期	:
//描述	    :
//=============================================================================================

//=============================================================================================
//包含头文件
//=============================================================================================
#include "SocTypeDef.h"
#include "SocCalcHook.h"

//=============================================================================================
//定义接口函数
//=============================================================================================
//=============================================================================================
//函数名称	: u8 SOCSearchAscendingTabs8(s8 data, const s8 *array, u8 len)
//输入参数	: data:查找的数据 array:数组基地址 len:数组长度 
//输出参数	: 查找到数据的下标
//函数功能	: 二份法查找s8升序数组
//注意事项	: 取高端值,注意len为1时
//=============================================================================================
u8 SOCSearchAscendingTabs8(s8 data, const s8 *array, u8 len)
{
    u8 left = 0;
    u8 right = len - 1;
    u8 mid = 0;

    if(data <= array[0] || len == 1)
    {
        return(0);
    }

    if(data >= array[len - 1])
    {
        return(len - 1);
    }

    while(left <= right)
    {
        mid = (u8)((u16)left + (u16)right) / 2;

        if(data == array[mid])
        {
            return(mid);
        }
        else if(data < array[mid])
        {
            right = mid - 1;	
        }
        else
        {
            left = mid + 1;	
        }
    }

    return(right);
}

//=============================================================================================
//函数名称	: u8 SOCSearchAscendingTabs16(s16 value, const s16 * array, u8 len)
//输入参数	: value:查找的数据 array:数组基地址 len:数组长度 
//输出参数	: 得到的下标
//函数功能	: 从s16升序数组中查找数据对应的下标
//注意事项	: 取高端值 
//=============================================================================================
u8 SOCSearchAscendingTabs16(s16 value, const s16 * array, u8 len)
{
    u8 temp = 0;
    
    for(temp = 0; temp < len; temp++)
	{
		if(value <= *(array + temp))
		{
			return(temp);
		}
	}
	
	return(len - 1);   
}

//=============================================================================================
//函数名称	: u8 SOCSearchAscendingOCVPointTabs(s16 temp, const t_OCVPoint * array, u8 len)
//输入参数	: temp:查找的温度 array:t_OCVPoint数组基地址 len:数组长度 
//输出参数	: 得到的下标
//函数功能	: 从t_OCVPoint的点温度数据查找对应温度的OCV点下标，升序
//注意事项	: 取高端值 
//=============================================================================================
u8 SOCSearchAscendingOCVPointTabs(s16 temp, const t_OCVPoint * array, u8 len)
{
    u8 i = 0;
    
    for(i = 0; i < len; i++)
	{
		if(temp <= array[i].temp)
		{
			return(i);
		}
	}
	
	return(len - 1);   
}

//=============================================================================================
//函数名称	: u32 SOCDataBCD2DEC(u32 bcd)  
//输入参数	: bcd:需要转换成DEC数的数据
//输出参数	: 转换后的DEC数
//函数功能	: 将BCD数据转换成DEC数
//注意事项	: 
//=============================================================================================
u32 SOCDataBCD2DEC(u32 bcd)  
{  
    return (bcd-(bcd>>4)*6);
}  

//=============================================================================================
//函数名称	: u32 SOCDataDEC2BCD(u32 dec)  
//输入参数	: dec:需要转换成BCD数的数据
//输出参数	: 转换后的BCD数
//函数功能	: 将DEC数据转换成BCD数
//注意事项	: 
//=============================================================================================
u32 SOCDataDEC2BCD(u32 dec)  
{  
    u32 retdec = 0;
    u32 temph = 0,templ = 0;
    
    if(dec > 99999999)  //8位BCD数最大值
    {
        return 99999999;
    }

    temph = dec / 10000000;  //最高位
    if(temph)
    {   
        retdec |= temph << 28;
    }
    
    templ = dec % 10000000;
    temph = templ / 1000000;
    if(temph)
    {   
        retdec |= temph << 24;
    }
    
    templ = templ % 1000000;
    temph = templ / 100000;
    if(temph)
    {   
        retdec |= temph << 20;
    }

    templ = templ % 100000;
    temph = templ / 10000;
    if(temph)
    {   
        retdec |= temph << 16;
    }    
    
    templ = templ % 10000;
    temph = templ / 1000;
    if(temph)
    {   
        retdec |= temph << 12;
    }       
    
    templ = templ % 1000;
    temph = templ / 100;
    if(temph)
    {   
        retdec |= temph << 8;
    }  

    templ = templ % 100;
    temph = templ / 10;
    if(temph)
    {   
        retdec |= temph << 4;
    }          
    
    templ = templ % 10;
    if(templ)
    {   
        retdec |= templ;
    }          

    return retdec;
} 

/*****************************************end of SocCalcHook.c*****************************************/
