/****************************************************************************/
/* 	File    	BSP_TEST.c 			 
 * 	Author		Hollis
 *	Notes			测试BSP功能  保持BSP内容纯净  非正式使用
 * 
 *	Version		Date    		Change Logs:
 *  V1.0.0 		2021-06-25	first version         	
 * 	
 * Copyright (c) 2021, Immotor
*****************************************************************************/
#include "BSP_TEST.h"
#include "BSP_SPI.h"
#include "BSP_GPIO.h"
#include "BSP_CAN.h"
#include "BSP_RTC.h"
#include "BSP_ADC.h"
#include "BSP_UART.h"
#include "BSP_IIC.h"
#include <string.h>

void MX25L16ReadDevID(void)
{	
	uint8_t SPI_TX_BUF[4];
	uint8_t SPI_RX_BUF[2];
	
	FLASH_POWER_ENABLE();
	SPI_TX_BUF[0] = 0x90;
	SPI_TX_BUF[1] = 0x00;
	SPI_TX_BUF[2] = 0x00;
	SPI_TX_BUF[3] = 0x00;
	FLASH_CS_ENABLE();
	SPI_Transmit(SPI_TX_BUF,  4,  10);
	SPI_Receive(SPI_RX_BUF,  2,  10);
//	SPI_TransmitReceive(SPI_TX_BUF,SPI_RX_BUF,2,100);
	FLASH_CS_DISABLE();
}

/*****************************************************
	* 函数功能: 读取时间测试
  * 输入参数: void
  * 返 回 值: 无
  * 说    明：无
******************************************************/
void MX_RTC_Test(void)
{
	RTC_InfoTypeDef NewInfo;
	RTC_GetInfo(&NewInfo);
//	HAL_RTC_GetTime(&hrtc,&(NewInfo.NewTime),0);
//	HAL_RTC_GetDate(&hrtc,&(NewInfo.NewData),0);
	_Debug_Printf("Now:Y-%d M-%d D-%d W-%d H-%d M-%d S-%d\n",NewInfo.NewData.Year,NewInfo.NewData.Month,NewInfo.NewData.Date,
	NewInfo.NewData.WeekDay,NewInfo.NewTime.Hours,NewInfo.NewTime.Minutes,NewInfo.NewTime.Seconds);
}

void MX_CAN_TEST(void)
{
	static uint16_t i;
	uint8_t CAN_TX_BUF[10];
	CAN_TX_BUF[0] = i++;
	CAN_TX_BUF[1] = 0x02;
	CAN_TX_BUF[2] = 0x03;
	CAN_TX_BUF[3] = 0x04;
	CAN_TX_BUF[4] = 0x02;
	CAN_TX_BUF[5] = 0x03;
	CAN_TX_BUF[6] = 0x04;
	CAN_TX_BUF[7] = 0x02;
	CAN_TX_BUF[8] = 0x03;
	CAN_TX_BUF[9] = 0x04;
//	PWR_EN_ENABLE();
	CAN_POWER_ENABLE();
	if(FDCAN2_SendMsg(CAN_TX_BUF , 10 ) != HAL_OK)
	{
		_Debug_Printf("can测试失败\n");
	}
}
//120424-1			CRC Table
const uint8_t CRC8Table[] =
{							
    0x00,0x07,0x0E,0x09,0x1C,0x1B,0x12,0x15,0x38,0x3F,0x36,0x31,0x24,0x23,0x2A,0x2D,
    0x70,0x77,0x7E,0x79,0x6C,0x6B,0x62,0x65,0x48,0x4F,0x46,0x41,0x54,0x53,0x5A,0x5D,
    0xE0,0xE7,0xEE,0xE9,0xFC,0xFB,0xF2,0xF5,0xD8,0xDF,0xD6,0xD1,0xC4,0xC3,0xCA,0xCD,
    0x90,0x97,0x9E,0x99,0x8C,0x8B,0x82,0x85,0xA8,0xAF,0xA6,0xA1,0xB4,0xB3,0xBA,0xBD,
    0xC7,0xC0,0xC9,0xCE,0xDB,0xDC,0xD5,0xD2,0xFF,0xF8,0xF1,0xF6,0xE3,0xE4,0xED,0xEA,
    0xB7,0xB0,0xB9,0xBE,0xAB,0xAC,0xA5,0xA2,0x8F,0x88,0x81,0x86,0x93,0x94,0x9D,0x9A,
    0x27,0x20,0x29,0x2E,0x3B,0x3C,0x35,0x32,0x1F,0x18,0x11,0x16,0x03,0x04,0x0D,0x0A,
    0x57,0x50,0x59,0x5E,0x4B,0x4C,0x45,0x42,0x6F,0x68,0x61,0x66,0x73,0x74,0x7D,0x7A,
    0x89,0x8E,0x87,0x80,0x95,0x92,0x9B,0x9C,0xB1,0xB6,0xBF,0xB8,0xAD,0xAA,0xA3,0xA4,
    0xF9,0xFE,0xF7,0xF0,0xE5,0xE2,0xEB,0xEC,0xC1,0xC6,0xCF,0xC8,0xDD,0xDA,0xD3,0xD4,
    0x69,0x6E,0x67,0x60,0x75,0x72,0x7B,0x7C,0x51,0x56,0x5F,0x58,0x4D,0x4A,0x43,0x44,
    0x19,0x1E,0x17,0x10,0x05,0x02,0x0B,0x0C,0x21,0x26,0x2F,0x28,0x3D,0x3A,0x33,0x34,
    0x4E,0x49,0x40,0x47,0x52,0x55,0x5C,0x5B,0x76,0x71,0x78,0x7F,0x6A,0x6D,0x64,0x63,
    0x3E,0x39,0x30,0x37,0x22,0x25,0x2C,0x2B,0x06,0x01,0x08,0x0F,0x1A,0x1D,0x14,0x13,
    0xAE,0xA9,0xA0,0xA7,0xB2,0xB5,0xBC,0xBB,0x96,0x91,0x98,0x9F,0x8A,0x8D,0x84,0x83,
    0xDE,0xD9,0xD0,0xD7,0xC2,0xC5,0xCC,0xCB,0xE6,0xE1,0xE8,0xEF,0xFA,0xFD,0xF4,0xF3
};
static uint8_t SH367309CalcCRC(uint8_t *dataptr, uint8_t len)
{
    uint8_t crc8 = 0;    
    
	for(; len > 0; len--)
	{    
        crc8 = CRC8Table[crc8^*dataptr];    
	    dataptr++;    
    } 
       
    return(crc8);       
}

void MX_IIC_AFE_TEST(void)
{
	uint32_t regAddr = 0x72 ;
	uint8_t IIC_TX_BUF[4];
	uint8_t IIC_RX_BUF[10];
	SH367309_ON_ENABLE();
//	HAL_GPIO_WritePin(VPRO_AFE_PORT, VPRO_AFE_PIN, GPIO_PIN_RESET);
	HAL_Delay(200);
	
	VPRO_AFE_HI();
	HAL_Delay(250);
	IIC_TX_BUF[0] = SH367309_WRITE_ADDR; 
	IIC_TX_BUF[1] = regAddr;  
	IIC_TX_BUF[2] = 0x02;  
	IIC_TX_BUF[3] = SH367309CalcCRC(IIC_TX_BUF , 3);  
	regAddr = 0x7202;
	I2C_WRITE(AFE_IIC_CH,regAddr, &IIC_TX_BUF[3], 1, 100);
	
	HAL_Delay(200);
	VPRO_AFE_LOW();
	HAL_Delay(100);
	
//	IIC_RX_BUF[0] = SH367309_WRITE_ADDR; 
//	IIC_RX_BUF[1] = regAddr;  
//	IIC_RX_BUF[2] = 0x87;  
//	IIC_RX_BUF[3] = SH367309CalcCRC(IIC_TX_BUF , 3);  
//	I2C_WRITE(regAddr, &IIC_RX_BUF[2], 2, 100);

	regAddr = 0x7201;
	I2C_REAR(AFE_IIC_CH,regAddr, IIC_RX_BUF, 2, 100);
	HAL_Delay(100);
	HAL_Delay(100);
	IIC_RX_BUF[0] = SH367309_WRITE_ADDR; 
	memset(IIC_RX_BUF , 0 ,8);
	
}

void MX_IIC_ACC_TEST(void)
{
	uint8_t ACC_RX_BUF[10];
	uint8_t ACC_TX_BUF[10];
	uint32_t regAddr = 0x01 ;
//	regAddr = 0x01;	//读取0x01地址   数据为0x13
//	I2C_REAR(ACC_IIC_CH,regAddr, ACC_RX_BUF, 1, 100);
//	HAL_Delay(100);
//	HAL_Delay(100);
	
	regAddr = 0x20;	//读取0x0F地址	
	I2C_REAR(ACC_IIC_CH,regAddr, ACC_RX_BUF, 1, 100);
	HAL_Delay(100);
	HAL_Delay(100);
	
	ACC_TX_BUF[0] = 0x00;								//读取0x0F地址数据
	I2C_WRITE(ACC_IIC_CH,regAddr, ACC_TX_BUF, 1, 100);
	HAL_Delay(100);
	HAL_Delay(100);
	
	regAddr = 0x20;	//读取0x0F地址	
	I2C_REAR(ACC_IIC_CH,regAddr, ACC_RX_BUF, 1, 100);
	HAL_Delay(100);
	HAL_Delay(100);
	
	ACC_TX_BUF[0] = 0x03;								//读取0x0F地址数据
	I2C_WRITE(ACC_IIC_CH,regAddr, ACC_TX_BUF, 1, 100);
	HAL_Delay(100);
	HAL_Delay(100);
	
	regAddr = 0x20;	//读取0x0F地址	
	I2C_REAR(ACC_IIC_CH,regAddr, ACC_RX_BUF, 1, 100);
	HAL_Delay(100);
	HAL_Delay(100);
	
}


void MX_ADC_TEST(void)
{
		_Debug_Printf("CH0:%d\n",ADC_Get_Average(0,10));
		HAL_Delay(5);
		_Debug_Printf("CH6:%d\n",ADC_Get_Average(6,10));
		HAL_Delay(5);
		_Debug_Printf("CH7:%d\n",ADC_Get_Average(7,10));
		HAL_Delay(5);
		_Debug_Printf("CH8:%d\n",ADC_Get_Average(8,10));
}

